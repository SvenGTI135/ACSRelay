#include "acsrelay.h"#ifdef WIN32    #include <ws2tcpip.h>#else    #include <sys/socket.h>	#include <sys/select.h>#endif#include <chrono>#include <iostream>#include "udpsocket.h"#include "log.h"ACSRelay* ACSRelay::mInstance = NULL;ACSRelay* ACSRelay::Build (){    if ( mInstance == NULL )    {        mInstance = new ACSRelay ();    }        return mInstance;}ACSRelay::ACSRelay (){    mMaxFd = 0;    mLocalPort = mRemotePort = -1;    mMri = ULONG_MAX;}void ACSRelay::AddPeer ( PeerConnection *plugin){    std::string host;        host = plugin -> GetSocket() -> Host();        if ( host == "")    {        // INCORRECT HOST AND/OR PORT FOR PLUGIN        return;    }        Log::v() << "Adding plugin " << plugin -> Name() <<  " (" << host << ":" << plugin -> GetSocket () -> RemotePort () << "). " << "Listening on local UDP port " << plugin -> GetSocket() -> LocalPort() << ".";    if ( plugin -> GetSocket () -> Fd () > mMaxFd )        mMaxFd = plugin -> GetSocket () -> Fd ();        mPeers[ plugin -> GetSocket() -> Fd () ] = plugin;}void ACSRelay::ReadConfiguration( std::string ini_fn ){    PeerConnection *p;    std::vector< std::string > sections;        INIReader *ir = new INIReader ();    ir -> parse ( ini_fn );    mLocalPort = (unsigned int) ir -> GetInteger ( "SERVER", "LOCAL_PORT", 9999 );    mRemotePort = (unsigned int) ir -> GetInteger( "SERVER", "REMOTE_PORT", 9998 );    mServerType = ir -> GetString ( "SERVER", "TYPE", "AC" ) == "AC" ? ServerType::AC : ServerType::RELAY;    mHost = ir -> GetString ( "SERVER", "IP", "127.0.0.1" );        sections = ir -> Sections ();        for ( int i = 0; i < sections.size (); i += 1 )    {        if ( sections[ i ].substr ( 0, 7 ) == "PLUGIN_" )        {            // ADD NEW PLUGIN                        p = new PeerConnection (                sections[ i ],                ir -> GetString ( sections[ i ], "IP", "127.0.0.1" ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "LOCAL_PORT", -1 ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "REMOTE_PORT", -1 )            );                        AddPeer ( p );        }    }        mRelayPort = ( unsigned int ) ir -> GetInteger ( "RELAY", "LOCAL_PORT", -1 );    delete ir;}void ACSRelay::RelayFromPlugin ( PeerConnection* plugin ){    long n;    char msg[ BUFFER_SIZE ];    int16_t ri;        n = plugin -> GetSocket() -> Read ( msg, BUFFER_SIZE );        Log::d() << "Caught message from " << plugin -> Name () << "!\n" << LogPacket ( msg, n );    if ( n < 1 )        // ERROR        return;            // Only send ACSP_REALTIMEPOS_INTERVAL to server if it's lower    // than before.    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_REALTIMEPOS_INTERVAL )    {        if ( n >= 3 )        {            ri = msg[ 1 ] << 8 | msg[ 2 ];            plugin -> SetCarUpdateInterval ( ri );                        if ( ri < mMri )            {                mMri = ri;                Log::d () << "Relaying packet to server.";                mServerSocket -> Send ( msg, n );            }        }    }    // This plugin is requesting info about a car. Take notice and make sure to    // relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_CAR_INFO )    {        plugin -> RequestCarInfo ( (int8_t) msg[ 1 ] );        Log::d () << "Relaying packet to server";        mServerSocket -> Send ( msg, n );    }    // This plugin is requesting info about a session. Take notice and make sure to relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_SESSION_INFO )    {        plugin -> RequestSessionInfo ( (int8_t) msg[ 1 ] );        Log::d () << "Relaying packet to server";        mServerSocket -> Send ( msg, n );    }    else    {        Log::d () << "Relaying packet to server";        mServerSocket -> Send ( msg, n );    }}void ACSRelay::RelayFromServer(){    long n;    char msg[ BUFFER_SIZE ];        n = mServerSocket -> Read ( msg, BUFFER_SIZE );        if ( n < 1 )        // ERROR        return;        Log::d() << "Caught message from  server!\n" << LogPacket ( msg, n );    // Send realtime position update to subscribed plugins    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_UPDATE )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            // Send ACSP_CAR_UPDATE packets to any plugin that is interested.            // A plugin will expect an ACSP_CAR_UPDATE packet only after            // its car update interval has elapsed.            //            // Also, if the plugin has the minimum car update interval make            // sure to send it the packet.            if ( p -> second -> IsWaitingCarUpdate ( (int8_t) msg[ 1 ] )                || p -> second -> CarUpdateInterval () == mMri )            {                Log::d () << "Relaying packet to " << p -> second -> Name ();                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarUpdateArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_CAR_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_INFO )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            if ( p -> second -> IsWaitingCarInfo ( (int8_t) msg[ 1 ] ) )            {                Log::d () << "Relaying packet to " << p -> second -> Name ();                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_SESSION_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_SESSION_INFO )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            if ( p -> second -> IsWaitingSessionInfo ( (int8_t) msg[ 1 ] ) )            {                Log::d () << "Relaying packet to " << p -> second -> Name ();                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> SessionInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // For other types of packets just relay the message to all plugins.    else    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            Log::d () << "Relaying packet to " << p -> second -> Name ();            p -> second -> GetSocket () -> Send ( msg, n );        }    }}void ACSRelay::Start(){    fd_set fds;        PeerConnection* plugin;    TCPSocket* tcp_socket;    if ( mLocalPort == -1 || mRemotePort == -1 )    {        Log::e () << "Trying to start non-configured relay. Aborting...";        exit ( 2 );    }        switch ( mServerType )    {        case ServerType::AC:            mServerSocket = new UDPSocket ( mLocalPort );            Log::v () << "Relay starting. Listening for messages from server on local UDP port " << mLocalPort << ".";            break;        case ServerType::RELAY:        default:            tcp_socket = new TCPSocket ( mHost, mRemotePort );            Log::v() << "Relay starting. Trying to connect with another relay (" << mHost << ":" << mRemotePort << ") via TCP" << "...";                        if ( tcp_socket -> Connect ( mTCPTimeout ) >= 0 )            {                Log::v() << " Connected!";            }            else            {                Log::v() << " Failed! ACSRelay is closing.";                exit ( 1 );            }            mServerSocket = (Socket*) tcp_socket;                        break;    }        if ( mRelayPort != -1 )    {        mRelaySocket = new TCPSocket ( TCPSocket::Type::SERVER, mRelayPort );        Log::v() << "Listening for messages from other relays on local TCP port " << mRelayPort << ".";    }    if ( mServerSocket -> Fd () > mMaxFd )        mMaxFd = mServerSocket -> Fd ();        if ( mRelaySocket != NULL )        mMaxFd = ( mMaxFd < mRelaySocket -> Fd () ) ? mRelaySocket -> Fd () : mMaxFd;        // Initially disable realtime car updates for all plugins.    for ( auto p = mPeers.begin(); p != mPeers.end (); ++p )    {        p -> second -> SetCarUpdateInterval ( 0 );    }        Log::i() << "Relay started.";        while ( 1 )    {        FD_ZERO ( &fds );            for ( auto p = mPeers.begin(); p != mPeers.end (); ++p )        {            FD_SET ( p -> second -> GetSocket () -> Fd (), &fds );                        // Check if a recently added plugin has a file descriptor            // bigger than the previous maximum value:                        if ( p -> second -> GetSocket() -> Fd () > mMaxFd )            {                mMaxFd = p -> second -> GetSocket() -> Fd ();            }        }            FD_SET ( mServerSocket -> Fd (), &fds );        if ( mRelaySocket != NULL )            FD_SET ( mRelaySocket -> Fd (), &fds );                select ( mMaxFd + 1, &fds, NULL, NULL, NULL );                for ( int i = 0; i <= mMaxFd; i++ )        {            if ( FD_ISSET ( i, &fds ) )            {                if ( i == mServerSocket -> Fd () )                {                    RelayFromServer ();                }                else                {                    if ( mRelaySocket != NULL && i == mRelaySocket -> Fd () )                    {                        tcp_socket = new TCPSocket ( TCPSocket::Type::FROM_FD, mRelaySocket -> Accept() );                        plugin = new PeerConnection ( "RELAY", (Socket*) tcp_socket );                        AddPeer ( plugin );                    }                    else                    {                        RelayFromPlugin ( mPeers[ i ] );                    }                }            }        }    }}