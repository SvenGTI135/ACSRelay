#include "acsrelay.h"#ifdef WIN32    #include <ws2tcpip.h>#else    #include <sys/socket.h>	#include <sys/select.h>#endif#include <chrono>#include <iostream>ACSRelay* ACSRelay::mInstance = NULL;ACSRelay* ACSRelay::Build (){    if ( mInstance == NULL )    {        mInstance = new ACSRelay ();    }        return mInstance;}ACSRelay::ACSRelay (){    mMaxFd = 0;    mLocalPort = mRemotePort = -1;    mMri = ULONG_MAX;    #ifdef DEBUG    dOut = std::ofstream ( "acsrelay_debug.txt" );#endif}void ACSRelay::AddPlugin ( PluginHandler *plugin){    std::string host;        host = plugin -> GetSocket() -> Host();        if ( host == "")    {        // INCORRECT HOST AND/OR PORT FOR PLUGIN        return;    }        std::cout << "Adding plugin" << plugin -> Name() <<  " (" << host << ":" << plugin -> GetSocket () -> RemotePort () << "). ";    std::cout << "Listening on local UDP port" << plugin -> GetSocket() -> LocalPort() << "." << std::endl;    if ( plugin -> GetSocket () -> Fd () > mMaxFd )        mMaxFd = plugin -> GetSocket () -> Fd ();        mPlugins[ plugin -> GetSocket() -> Fd () ] = plugin;}void ACSRelay::ReadConfiguration( std::string ini_fn ){    PluginHandler *p;    std::vector< std::string > sections;        INIReader *ir = new INIReader ();    ir -> parse ( ini_fn );    mLocalPort = (unsigned int) ir -> GetInteger ( "SERVER", "LOCAL_PORT", 9999 );    mRemotePort = (unsigned int) ir -> GetInteger( "SERVER", "REMOTE_PORT", 9998 );        sections = ir -> Sections ();        for ( int i = 0; i < sections.size (); i += 1 )    {        if ( sections[ i ].substr ( 0, 7 ) == "PLUGIN_" )        {            // ADD NEW PLUGIN                        p = new PluginHandler (                sections[ i ],                ir -> GetString ( sections[ i ], "IP", "127.0.0.1" ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "LOCAL_PORT", -1 ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "REMOTE_PORT", -1 )            );                        AddPlugin ( p );        }    }    delete ir;}void ACSRelay::RelayFromPlugin ( PluginHandler* plugin ){    long n;    char msg[ BUFFER_SIZE ];    int16_t ri;        n = recvfrom ( plugin -> GetSocket () -> Fd (), msg, BUFFER_SIZE, 0, NULL, 0 );    #ifdef DEBUG    OutputString ( std::string ( ">>> Caught message from " + plugin -> Name() + "!" ) );    OutputPacket ( msg, n );#endif    if ( n < 1 )        // ERROR        return;            // Only send ACSP_REALTIMEPOS_INTERVAL to server if it's lower    // than before.    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_REALTIMEPOS_INTERVAL )    {        if ( n >= 3 )        {            ri = msg[ 1 ] << 8 | msg[ 2 ];            plugin -> SetCarUpdateInterval ( ri );                        if ( ri < mMri )            {                mMri = ri;#ifdef DEBUG                OutputString( "\tRelaying packet to server" );#endif                mServerSocket -> Send ( msg, n );            }        }    }    // This plugin is requesting info about a car. Take notice and make sure to    // relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_CAR_INFO )    {        plugin -> RequestCarInfo ( (int8_t) msg[ 1 ] );#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }    // This plugin is requesting info about a session. Take notice and make sure to relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_SESSION_INFO )    {        plugin -> RequestSessionInfo ( (int8_t) msg[ 1 ] );#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }    else    {#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }}void ACSRelay::RelayFromServer(){    long n;    char msg[ BUFFER_SIZE ];        n = recvfrom( mServerSocket -> Fd (), msg, BUFFER_SIZE, 0, NULL, 0 );        if ( n < 1 )        // ERROR        return;    #ifdef DEBUG    OutputString ( ">>> Caught message from server!" );    OutputPacket ( msg, n );#endif    // Send realtime position update to subscribed plugins    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_UPDATE )    {        for ( auto p = mPlugins.begin (); p != mPlugins.end (); ++p )        {            // Send ACSP_CAR_UPDATE packets to any plugin that is interested.            // A plugin will expect an ACSP_CAR_UPDATE packet only after            // its car update interval has elapsed.            //            // Also, if the plugin has the minimum car update interval make            // sure to send it the packet.            if ( p -> second -> IsWaitingCarUpdate ( (int8_t) msg[ 1 ] )                || p -> second -> CarUpdateInterval () == mMri )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarUpdateArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_CAR_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_INFO )    {        for ( auto p = mPlugins.begin (); p != mPlugins.end (); ++p )        {            if ( p -> second -> IsWaitingCarInfo ( (int8_t) msg[ 1 ] ) )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_SESSION_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_SESSION_INFO )    {        for ( auto p = mPlugins.begin (); p != mPlugins.end (); ++p )        {            if ( p -> second -> IsWaitingSessionInfo ( (int8_t) msg[ 1 ] ) )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> SessionInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // For other types of packets just relay the message to all plugins.    else    {        for ( auto p = mPlugins.begin (); p != mPlugins.end (); ++p )        {#ifdef DEBUG            OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif            p -> second -> GetSocket () -> Send ( msg, n );        }    }}void ACSRelay::Start(){    fd_set fds;    struct sockaddr_in sa;    socklen_t len;    struct timeval t;        t.tv_sec = 1;    t.tv_usec = 0;        char one_byte[1];    if ( mLocalPort == -1 || mRemotePort == -1 )    {        std::cerr << "Trying to start non-configured relay. Aborting..." << std::endl;    }        std::cout << "Starting relay. Listening for messages from server on local UDP port " << mLocalPort << "." << std::endl;    mServerSocket = new Socket ( mLocalPort );    if ( mServerSocket -> Fd () > mMaxFd )        mMaxFd = mServerSocket -> Fd ();        // Initially disable realtime car updates for all plugins.    for ( auto p = mPlugins.begin(); p != mPlugins.end (); ++p )    {        p -> second -> SetCarUpdateInterval ( 0 );    }        std::cout << "Relay started." << std::endl;        while ( 1 )    {        FD_ZERO ( &fds );            for ( auto p = mPlugins.begin(); p != mPlugins.end (); ++p )        {            FD_SET ( p -> second -> GetSocket () -> Fd (), &fds );        }            FD_SET ( mServerSocket -> Fd (), &fds );                select ( mMaxFd + 1, &fds, NULL, NULL, NULL );                for ( int i = 0; i <= mMaxFd; i++ )        {            if ( FD_ISSET ( i, &fds ) )            {                if ( i != mServerSocket -> Fd () )                    RelayFromPlugin ( mPlugins[ i ] );                else                {                    len = (socklen_t) sizeof ( struct sockaddr_in );                    // Peek inside the datagram to retrieve server address and port.                    recvfrom( mServerSocket -> Fd (), one_byte, 1, MSG_PEEK, (struct sockaddr*) &sa, &len );                                        // Store them in order to know where to send datagrams at a later time.                    mServerSocket -> SetAddress ( sa.sin_addr.s_addr );                    mServerSocket -> SetRemotePort ( mRemotePort );                                                          RelayFromServer ();                }            }        }    }}#ifdef DEBUGvoid ACSRelay::OutputString ( const std::string msg ){    std::cout << msg << std::endl;    dOut << msg << std::endl;}void ACSRelay::OutputPacket ( const char* msg, long n ){    switch ( (int8_t) msg[ 0 ] )    {        case ACSProtocol::ACSP_BROADCAST_CHAT:        {            std::cout << "\t" << "ACSP_BROADCAST_CHAT" << std::endl;            dOut << "\t" << "ACSP_BROADCAST_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_CAR_INFO:        {            std::cout << "\t" << "ACSP_CAR_INFO" << std::endl;            dOut << "\t" << "ACSP_CAR_UPDATE" << std::endl;        }; break;        case ACSProtocol::ACSP_CAR_UPDATE:        {            std::cout << "\t" << "ACSP_CAR_UPDATE" << std::endl;            dOut << "\t" << "ACSP_CAR_UPDATE" << std::endl;        }; break;        case ACSProtocol::ACSP_CE_COLLISION_WITH_CAR:        {            std::cout << "\t" << "ACSP_CE_COLLISION_WITH_CAR" << std::endl;            dOut << "\t" << "ACSP_CE_COLLISION_WITH_CAR" << std::endl;        }; break;        case ACSProtocol::ACSP_CE_COLLISION_WITH_ENV:        {            std::cout << "\t" << "ACSP_CE_COLLISION_WITH_ENV" << std::endl;            dOut << "\t" << "ACSP_CE_COLLISION_WITH_ENV" << std::endl;        }; break;        case ACSProtocol::ACSP_CHAT:        {            std::cout << "\t" << "ACSP_CHAT" << std::endl;            dOut << "\t" << "ACSP_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_CLIENT_EVENT:        {            std::cout << "\t" << "ACSP_CLIENT_EVENT" << std::endl;            dOut << "\t" << "ACSP_CLIENT_EVENT" << std::endl;        }; break;        case ACSProtocol::ACSP_CLIENT_LOADED:        {            std::cout << "\t" << "ACSP_CLIENT_LOADED" << std::endl;            dOut << "\t" << "ACSP_CLIENT_LOADED" << std::endl;        }; break;        case ACSProtocol::ACSP_CONNECTION_CLOSED:        {            std::cout << "\t" << "ACSP_CONNECTION_CLOSED" << std::endl;            dOut << "\t" << "ACSP_CONNECTION_CLOSED" << std::endl;        }; break;        case ACSProtocol::ACSP_END_SESSION:        {            std::cout << "\t" << "ACSP_END_SESSION" << std::endl;            dOut << "\t" << "ACSP_END_SESSION" << std::endl;        }; break;        case ACSProtocol::ACSP_ERROR:        {            std::cout << "\t" << "ACSP_ERROR" << std::endl;            dOut << "\t" << "ACSP_ERROR" << std::endl;        }; break;        case ACSProtocol::ACSP_GET_CAR_INFO:        {            std::cout << "\t" << "ACSP_GET_CAR_INFO" << std::endl;            dOut << "\t" << "ACSP_GET_CAR_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_GET_SESSION_INFO:        {            std::cout << "\t" << "ACSP_GET_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_GET_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_KICK_USER:        {            std::cout << "\t" << "ACSP_KICK_USER" << std::endl;            dOut << "\t" << "ACSP_KICK_USER" << std::endl;        }; break;        case ACSProtocol::ACSP_LAP_COMPLETED:        {            std::cout << "\t" << "ACSP_LAP_COMPLETED" << std::endl;            dOut << "\t" << "ACSP_LAP_COMPLETED" << std::endl;        }; break;        case ACSProtocol::ACSP_NEW_CONNECTION:        {            std::cout << "\t" << "ACSP_NEW_CONNECTION" << std::endl;            dOut << "\t" << "ACSP_NEW_CONNECTION" << std::endl;        }; break;        case ACSProtocol::ACSP_NEW_SESSION:        {            std::cout << "\t" << "ACSP_NEW_SESSION" << std::endl;            dOut << "\t" << "ACSP_NEW_SESSION" << std::endl;        }; break;        case ACSProtocol::ACSP_REALTIMEPOS_INTERVAL:        {            std::cout << "\t" << "ACSP_REALTIMEPOS_INTERVAL" << std::endl;            dOut << "\t" << "ACSP_REALTIMEPOS_INTERVAL" << std::endl;        }; break;        case ACSProtocol::ACSP_SEND_CHAT:        {            std::cout << "\t" << "ACSP_SEND_CHAT" << std::endl;            dOut << "\t" << "ACSP_SEND_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_SESSION_INFO:        {            std::cout << "\t" << "ACSP_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_SET_SESSION_INFO:        {            std::cout << "\t" << "ACSP_SET_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_SET_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_VERSION:        {            std::cout << "\t" << "ACSP_VERSION" << std::endl;            dOut << "\t" << "ACSP_VERSION" << std::endl;        }; break;    }}#endif // DEBUG