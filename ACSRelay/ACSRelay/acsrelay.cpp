#include "acsrelay.h"#ifdef WIN32    #include <ws2tcpip.h>#else    #include <sys/socket.h>	#include <sys/select.h>#endif#include <chrono>#include <iostream>#include "udpsocket.h"ACSRelay* ACSRelay::mInstance = NULL;ACSRelay* ACSRelay::Build (){    if ( mInstance == NULL )    {        mInstance = new ACSRelay ();    }        return mInstance;}ACSRelay::ACSRelay (){    mMaxFd = 0;    mLocalPort = mRemotePort = -1;    mMri = ULONG_MAX;    #ifdef DEBUG    dOut = std::ofstream ( "acsrelay_debug.txt" );#endif}void ACSRelay::AddPeer ( PeerConnection *plugin){    std::string host;        host = plugin -> GetSocket() -> Host();        if ( host == "")    {        // INCORRECT HOST AND/OR PORT FOR PLUGIN        return;    }        std::cout << "Adding plugin" << plugin -> Name() <<  " (" << host << ":" << plugin -> GetSocket () -> RemotePort () << "). ";    std::cout << "Listening on local UDP port" << plugin -> GetSocket() -> LocalPort() << "." << std::endl;    if ( plugin -> GetSocket () -> Fd () > mMaxFd )        mMaxFd = plugin -> GetSocket () -> Fd ();        mPeers[ plugin -> GetSocket() -> Fd () ] = plugin;}void ACSRelay::ReadConfiguration( std::string ini_fn ){    PeerConnection *p;    std::vector< std::string > sections;        INIReader *ir = new INIReader ();    ir -> parse ( ini_fn );    mLocalPort = (unsigned int) ir -> GetInteger ( "SERVER", "LOCAL_PORT", 9999 );    mRemotePort = (unsigned int) ir -> GetInteger( "SERVER", "REMOTE_PORT", 9998 );    mServerType = ir -> GetString ( "SERVER", "TYPE", "AC" ) == "AC" ? ServerType::AC : ServerType::RELAY;    mHost = ir -> GetString ( "SERVER", "IP", "127.0.0.1" );        sections = ir -> Sections ();        for ( int i = 0; i < sections.size (); i += 1 )    {        if ( sections[ i ].substr ( 0, 7 ) == "PLUGIN_" )        {            // ADD NEW PLUGIN                        p = new PeerConnection (                sections[ i ],                ir -> GetString ( sections[ i ], "IP", "127.0.0.1" ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "LOCAL_PORT", -1 ),                ( unsigned int ) ir -> GetInteger ( sections[ i ], "REMOTE_PORT", -1 )            );                        AddPeer ( p );        }    }        mRelayPort = ( unsigned int ) ir -> GetInteger ( "RELAY", "LOCAL_PORT", -1 );    delete ir;}void ACSRelay::RelayFromPlugin ( PeerConnection* plugin ){    long n;    char msg[ BUFFER_SIZE ];    int16_t ri;        n = plugin -> GetSocket() -> Read ( msg, BUFFER_SIZE );    #ifdef DEBUG    OutputString ( std::string ( ">>> Caught message from " + plugin -> Name() + "!" ) );    OutputPacket ( msg, n );#endif    if ( n < 1 )        // ERROR        return;            // Only send ACSP_REALTIMEPOS_INTERVAL to server if it's lower    // than before.    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_REALTIMEPOS_INTERVAL )    {        if ( n >= 3 )        {            ri = msg[ 1 ] << 8 | msg[ 2 ];            plugin -> SetCarUpdateInterval ( ri );                        if ( ri < mMri )            {                mMri = ri;#ifdef DEBUG                OutputString( "\tRelaying packet to server" );#endif                mServerSocket -> Send ( msg, n );            }        }    }    // This plugin is requesting info about a car. Take notice and make sure to    // relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_CAR_INFO )    {        plugin -> RequestCarInfo ( (int8_t) msg[ 1 ] );#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }    // This plugin is requesting info about a session. Take notice and make sure to relay the server's response to this plugin.    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_GET_SESSION_INFO )    {        plugin -> RequestSessionInfo ( (int8_t) msg[ 1 ] );#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }    else    {#ifdef DEBUG        OutputString( "\tRelaying packet to server" );#endif        mServerSocket -> Send ( msg, n );    }}void ACSRelay::RelayFromServer(){    long n;    char msg[ BUFFER_SIZE ];        n = mServerSocket -> Read ( msg, BUFFER_SIZE );        if ( n < 1 )        // ERROR        return;    #ifdef DEBUG    OutputString ( ">>> Caught message from server!" );    OutputPacket ( msg, n );#endif    // Send realtime position update to subscribed plugins    if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_UPDATE )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            // Send ACSP_CAR_UPDATE packets to any plugin that is interested.            // A plugin will expect an ACSP_CAR_UPDATE packet only after            // its car update interval has elapsed.            //            // Also, if the plugin has the minimum car update interval make            // sure to send it the packet.            if ( p -> second -> IsWaitingCarUpdate ( (int8_t) msg[ 1 ] )                || p -> second -> CarUpdateInterval () == mMri )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarUpdateArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_CAR_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_CAR_INFO )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            if ( p -> second -> IsWaitingCarInfo ( (int8_t) msg[ 1 ] ) )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> CarInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // One or more of the plugins requested ACSP_SESSION_INFO. Send it to interested plugin(s).    else if ( (int8_t) msg[ 0 ] == ACSProtocol::ACSP_SESSION_INFO )    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {            if ( p -> second -> IsWaitingSessionInfo ( (int8_t) msg[ 1 ] ) )            {#ifdef DEBUG                OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif                p -> second -> GetSocket () -> Send ( msg, n );                p -> second -> SessionInfoArrived ( (int8_t) msg[ 1 ] );            }        }    }    // For other types of packets just relay the message to all plugins.    else    {        for ( auto p = mPeers.begin (); p != mPeers.end (); ++p )        {#ifdef DEBUG            OutputString( std::string ( "\tRelaying packet to " + p -> second -> Name() ) );#endif            p -> second -> GetSocket () -> Send ( msg, n );        }    }}void ACSRelay::Start(){    fd_set fds;        PeerConnection* plugin;    TCPSocket* tcp_socket;    if ( mLocalPort == -1 || mRemotePort == -1 )    {        std::cerr << "Trying to start non-configured relay. Aborting..." << std::endl;    }        switch ( mServerType )    {        case ServerType::AC:            mServerSocket = new UDPSocket ( mLocalPort );            std::cout << "Relay started. Listening for messages from server on local UDP port " << mLocalPort << "." << std::endl;            break;        case ServerType::RELAY:        default:            tcp_socket = new TCPSocket ( mHost, mRemotePort );            std::cout << "Relay starting. Trying to connect with another relay (" << mHost << ":" << mRemotePort << ") via TCP" << "..." << std::flush;            if ( tcp_socket -> Connect ( mTCPTimeout ) >= 0 )            {                std::cout << " Connected!" << std::endl;            }            else            {                std::cout << " Failed! ACSRelay is closing." << std::endl;                exit ( 1 );            }            mServerSocket = (Socket*) tcp_socket;                        break;    }        if ( mRelayPort != -1 )    {        mRelaySocket = new TCPSocket ( TCPSocket::Type::SERVER, mRelayPort );        std::cout << "Listening for messages from other relays on local TCP port " << mRelayPort << "." << std::endl;    }    if ( mServerSocket -> Fd () > mMaxFd )        mMaxFd = mServerSocket -> Fd ();        if ( mRelaySocket != NULL )        mMaxFd = ( mMaxFd < mRelaySocket -> Fd () ) ? mRelaySocket -> Fd () : mMaxFd;        // Initially disable realtime car updates for all plugins.    for ( auto p = mPeers.begin(); p != mPeers.end (); ++p )    {        p -> second -> SetCarUpdateInterval ( 0 );    }        std::cout << "Relay started." << std::endl;        while ( 1 )    {        FD_ZERO ( &fds );            for ( auto p = mPeers.begin(); p != mPeers.end (); ++p )        {            FD_SET ( p -> second -> GetSocket () -> Fd (), &fds );                        // Check if a recently added plugin has a file descriptor            // bigger than the previous maximum value:                        if ( p -> second -> GetSocket() -> Fd () > mMaxFd )            {                mMaxFd = p -> second -> GetSocket() -> Fd ();            }        }            FD_SET ( mServerSocket -> Fd (), &fds );        if ( mRelaySocket != NULL )            FD_SET ( mRelaySocket -> Fd (), &fds );                select ( mMaxFd + 1, &fds, NULL, NULL, NULL );                for ( int i = 0; i <= mMaxFd; i++ )        {            if ( FD_ISSET ( i, &fds ) )            {                if ( i == mServerSocket -> Fd () )                {                    RelayFromServer ();                }                else                {                    if ( mRelaySocket != NULL && i == mRelaySocket -> Fd () )                    {                        tcp_socket = new TCPSocket ( TCPSocket::Type::FROM_FD, mRelaySocket -> Accept() );                        plugin = new PeerConnection ( "RELAY", (Socket*) tcp_socket );                        AddPeer ( plugin );                    }                    else                    {                        RelayFromPlugin ( mPeers[ i ] );                    }                }            }        }    }}#ifdef DEBUGvoid ACSRelay::OutputString ( const std::string msg ){    std::cout << msg << std::endl;    dOut << msg << std::endl;}void ACSRelay::OutputPacket ( const char* msg, long n ){    switch ( (int8_t) msg[ 0 ] )    {        case ACSProtocol::ACSP_BROADCAST_CHAT:        {            std::cout << "\t" << "ACSP_BROADCAST_CHAT" << std::endl;            dOut << "\t" << "ACSP_BROADCAST_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_CAR_INFO:        {            std::cout << "\t" << "ACSP_CAR_INFO" << std::endl;            dOut << "\t" << "ACSP_CAR_UPDATE" << std::endl;        }; break;        case ACSProtocol::ACSP_CAR_UPDATE:        {            std::cout << "\t" << "ACSP_CAR_UPDATE" << std::endl;            dOut << "\t" << "ACSP_CAR_UPDATE" << std::endl;        }; break;        case ACSProtocol::ACSP_CE_COLLISION_WITH_CAR:        {            std::cout << "\t" << "ACSP_CE_COLLISION_WITH_CAR" << std::endl;            dOut << "\t" << "ACSP_CE_COLLISION_WITH_CAR" << std::endl;        }; break;        case ACSProtocol::ACSP_CE_COLLISION_WITH_ENV:        {            std::cout << "\t" << "ACSP_CE_COLLISION_WITH_ENV" << std::endl;            dOut << "\t" << "ACSP_CE_COLLISION_WITH_ENV" << std::endl;        }; break;        case ACSProtocol::ACSP_CHAT:        {            std::cout << "\t" << "ACSP_CHAT" << std::endl;            dOut << "\t" << "ACSP_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_CLIENT_EVENT:        {            std::cout << "\t" << "ACSP_CLIENT_EVENT" << std::endl;            dOut << "\t" << "ACSP_CLIENT_EVENT" << std::endl;        }; break;        case ACSProtocol::ACSP_CLIENT_LOADED:        {            std::cout << "\t" << "ACSP_CLIENT_LOADED" << std::endl;            dOut << "\t" << "ACSP_CLIENT_LOADED" << std::endl;        }; break;        case ACSProtocol::ACSP_CONNECTION_CLOSED:        {            std::cout << "\t" << "ACSP_CONNECTION_CLOSED" << std::endl;            dOut << "\t" << "ACSP_CONNECTION_CLOSED" << std::endl;        }; break;        case ACSProtocol::ACSP_END_SESSION:        {            std::cout << "\t" << "ACSP_END_SESSION" << std::endl;            dOut << "\t" << "ACSP_END_SESSION" << std::endl;        }; break;        case ACSProtocol::ACSP_ERROR:        {            std::cout << "\t" << "ACSP_ERROR" << std::endl;            dOut << "\t" << "ACSP_ERROR" << std::endl;        }; break;        case ACSProtocol::ACSP_GET_CAR_INFO:        {            std::cout << "\t" << "ACSP_GET_CAR_INFO" << std::endl;            dOut << "\t" << "ACSP_GET_CAR_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_GET_SESSION_INFO:        {            std::cout << "\t" << "ACSP_GET_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_GET_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_KICK_USER:        {            std::cout << "\t" << "ACSP_KICK_USER" << std::endl;            dOut << "\t" << "ACSP_KICK_USER" << std::endl;        }; break;        case ACSProtocol::ACSP_LAP_COMPLETED:        {            std::cout << "\t" << "ACSP_LAP_COMPLETED" << std::endl;            dOut << "\t" << "ACSP_LAP_COMPLETED" << std::endl;        }; break;        case ACSProtocol::ACSP_NEW_CONNECTION:        {            std::cout << "\t" << "ACSP_NEW_CONNECTION" << std::endl;            dOut << "\t" << "ACSP_NEW_CONNECTION" << std::endl;        }; break;        case ACSProtocol::ACSP_NEW_SESSION:        {            std::cout << "\t" << "ACSP_NEW_SESSION" << std::endl;            dOut << "\t" << "ACSP_NEW_SESSION" << std::endl;        }; break;        case ACSProtocol::ACSP_REALTIMEPOS_INTERVAL:        {            std::cout << "\t" << "ACSP_REALTIMEPOS_INTERVAL" << std::endl;            dOut << "\t" << "ACSP_REALTIMEPOS_INTERVAL" << std::endl;        }; break;        case ACSProtocol::ACSP_SEND_CHAT:        {            std::cout << "\t" << "ACSP_SEND_CHAT" << std::endl;            dOut << "\t" << "ACSP_SEND_CHAT" << std::endl;        }; break;        case ACSProtocol::ACSP_SESSION_INFO:        {            std::cout << "\t" << "ACSP_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_SET_SESSION_INFO:        {            std::cout << "\t" << "ACSP_SET_SESSION_INFO" << std::endl;            dOut << "\t" << "ACSP_SET_SESSION_INFO" << std::endl;        }; break;        case ACSProtocol::ACSP_VERSION:        {            std::cout << "\t" << "ACSP_VERSION" << std::endl;            dOut << "\t" << "ACSP_VERSION" << std::endl;        }; break;    }}#endif // DEBUG